summary(lm(medv~.))
summary(lm(medv~., data=Boston))
library(car)      # To use the VIF function for calculating collinearity
install.packages("car")
library(car)      # To use the VIF function for calculating collinearity
library(MASS)     # a very large collection of data sets and functions
library(graphics) # for plotting
library(ISLR)     # To load datasets associated with ISLR.
library(car)      # To use the VIF function for calculating collinearity
vif(lm(medv~., data=Boston))
mlm1.fit=lm(medv~.-age)
mlm1.fit=lm(medv~.-age,data=Boston)
summary(mlm1.fit)
mlm1.fit=lm(medv~.-age-indus,data=Boston)
summary(mlm1.fit)
ilm.fit=lm(medv~lstat*age,data=Boston)
summary(ilm.fit)
plot(ilm.fit)
ilm.fit=lm(medv~lstat*age,data=Boston)
summary(ilm.fit)
plot(ilm.fit)
par(mfrow=c(2,2))
ilm.fit=lm(medv~lstat*age,data=Boston)
summary(ilm.fit)
plot(ilm.fit)
nlm.fit=lm(medv~lstats+I(lstats^2),data=Boston)
summary(nlm.fit)
plot(nlm.fit)
nlm.fit=lm(medv~lstats+I(lstats^2),data=Boston)
nlm.fit=lm(medv~lstats+I(lstats^2),data=Boston)
nlm.fit=lm(medv~lstat+I(lstat^2),data=Boston)
summary(nlm.fit)
plot(nlm.fit)
anova(lm.fit ,nlm.fit)
names(Carseats)
summary(Carseats)
fix(Carseats)
qlm.fit=lm(Sales~.+Income+Advertising+Price:age)
qlm.fit=lm(Sales~.+Income+Advertising+Price:age,data=Carseats)
qlm.fit=lm(Sales~.+Income+Advertising+Price:Age,data=Carseats)
qlm.fit=lm(Sales~.+Income+Advertising+Price:Age,data=Carseats)
plot(ilm.fit)
clear
cls
pwd
getpwd
summary(qlm.fit)
plot(qlm.fit)
names(Smarket)
fix(Smarket)
cor(Boston)
cor(Carseats)
fix(Carseats)
names(Carseats)
cor(Carseats~-ShelveLoc)
cor(Carseats[,9])
cor(Carseats[,-7])
fix(Carseats)
cor(Carseats[,-7])
dim(Carseats)
cor(Carseats[,-7])
fix(Carseats) ###
cor(Carseats[,-7,10,11])
cor(Carseats[,-7,-10,-11])
cor(Carseats[,-c(7,10,11)])
pairs(Smarket)
pairs(Smarket)
cor(Smarket)
cor(Smarket[,-9])
attach(Smarket)
plot(Volume)
glm.fit=glm(Direction∼Lag1+Lag2+Lag3+Lag4+Lag5+Volume , data=Smarket ,family=binomial )
glm.fit=glm(Direction∼Lag1+Lag2+Lag3+Lag4+Lag5+Volume , data=Smarket ,family=binomial )
summary(glm.fit)
summary (glm.fit )$coef
glm.probs =predict (glm .fit ,type =" response ")
glm.probs =predict (glm.fit ,type =" response ")
glm.probs =predict (glm.fit ,type="response ")
glm.probs=predict(glm.fit ,type="response ")
glm.probs=predict(glm.fit ,type="response")
glm.probs [1:10]
contrasts(Direction)
dim(Smarket)
glm.pred <- rep("Down",1250)
glm.pred <- rep("Down",1250)
glm.pred[glm.probs > 0.5] <-"Up"
table(glm .pred ,Direction )
table(glm.pred ,Direction )
mean(glm.pred== Direction )
train=(Year<2005)
Smarket.2005=![train,]
Smarket.2005=[!train,]
Smarket.2005=Smarket[!train,]
dim(Smarket.2005)
Direction.2005=Direction[!train]
glm.pred=rep("Down",252)
glm.pred=rep("Down",252)
glm.pred[glm.probs>0.5]="Up"
table(glm.pred,Direction)
table(glm.pred,Direction.2005)
table(glm.pred,Direction.2005)
dim(Smarket.2005)
glm.pred=rep("Down",252)
glm.pred[glm.probs>0.5]="Up"
table(glm.pred,Direction.2005)
dim(Direction.2005)
glm.fit=glm(Direction.2005∼Lag1+Lag2+Lag3+Lag4+Lag5+Volume ,data=Smarket ,family=binomial ,subset=train )
glm.fit=glm(Direction.2005~Lag1+Lag2+Lag3+Lag4+Lag5+Volume ,data=Smarket ,family=binomial ,subset=train )
glm.fit=glm(Direction.2005~Lag1+Lag2+Lag3+Lag4+Lag5+Volume ,data=Smarket ,family=binomial ,subset=train )
glm.fit=glm(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume ,data=Smarket ,family=binomial ,subset=train )
glm.probs =predict (glm.fit ,Smarket.2005 , type="response")
glm.pred=rep("Down",252)
glm.pred[glm.probs>0.5]="Up"
table(glm.pred,Direction.2005)
mean(glm.pred== Direction .2005)
mean(glm.pred== Direction.2005)
glm.fit=glm(Direction~Lag1+Lag2,data=Smarket ,family=binomial ,subset=train )
glm.fit=glm(Direction~Lag1+Lag2,data=Smarket ,family=binomial ,subset=train )
glm.probs =predict (glm.fit ,Smarket.2005 , type="response")
dim(Direction.2005)
glm.pred=rep("Down",252)
glm.pred[glm.probs>0.5]="Up"
table(glm.pred,Direction.2005)
mean(glm.pred== Direction.2005)
predict(glm.fit,newdata = data.frame(Lag1=c(1.2,1.4,1.6),Lag2=c(1.1,.9,.7)),type="response")
library (class)
train.X=cbind(Lag1 ,Lag2)[train ,]
test.X=cbind (Lag1 ,Lag2)[!train ,]
train.Direction =Direction [train]
knn.pred=knn(train.X,test.X,train.Direction,k=1)
table(knn.pred ,Direction.2005)
knn.pred=knn(train.X,test.X,train.Direction,k=5)
table(knn.pred ,Direction.2005)
knn.pred=knn(train.X,test.X,train.Direction,k=3)
table(knn.pred ,Direction.2005)
fix(Caravan)
names(Caravan)
cor(Caravan)
dim(Caravan)
fix(Caravan)
cor(Caravan[,-86])
summary(Purchase)
attach(Caravan)
summary(Purchase)
glm_cara.fit=glm(Purchase~.,data=Caravan)
standardized.X=scale(Caravan [,-86])
var(Caravan[,1])
var(Caravan[,2])
var(standardized.X[,1])
var(standardized.X[,2])
train.X=standardized.X[-test,]
test.X=standardized.X[test,]
test=1:1000
train.X=standardized.X[-test,]
test.X=standardized.X[test,]
train.Y=standardized.X[-test,]
test.Y=standardized.X[test,]
set.seed(2)
knn.pred=knn(train.X,test.X,train.Y,k=1)
knn.pred=knn(train.X,test.X,train.Y,k=1)
train.Y=Purchase[-test,]
test.Y=Purchase[test,]
train.Y=Purchase[-test]
test.Y=Purchase[test]
knn.pred=knn(train.X,test.X,train.Y,k=1)
mean(test.Y!="No")
## Include Libraries.
library(MASS)     # a very large collection of data sets and functions
library(graphics) # for plotting
library(ISLR)     # To load datasets associated with ISLR.
library(car)      # To use the VIF function for calculating collinearity
set.seed(1001)
train=sample(392,196)
?sample
max(train)
max(-train)
max(!train)
data("Auto")
names(Auto)
attach(Auto)
lm.fit=lm(mpg~horsepower,subset = train)
dim(lm.fit)
plot(lm.fit)
mean((mpg-predict(lm.fit,Auto)[-train]^2))
mean((mpg-predict(lm.fit,Auto))[-train]^2)
train=sample(392,196)
### dataset used is Auto
data("Auto")
attach(Auto)
names(Auto)
lm.fit=lm(mpg~horsepower,subset = train)
## Calculate MSE
mean((mpg-predict(lm.fit,Auto))[-train]^2)
train=sample(392,196)
### dataset used is Auto
data("Auto")
attach(Auto)
names(Auto)
lm.fit=lm(mpg~horsepower,subset = train)
## Calculate MSE
mean((mpg-predict(lm.fit,Auto))[-train]^2)
lm.fit.poly=lm(mpg~poly(horsepower,3),subset=train)
lm.fit.poly=lm(mpg~poly(horsepower,3),subset=train)
mean((mpg-predict(lm.fit.poly,Auto))[-train]^2)
lm.fit.poly=lm(mpg~poly(horsepower,2),subset=train)
mean((mpg-predict(lm.fit.poly,Auto))[-train]^2)
lm.fit.poly=lm(mpg~poly(horsepower,5),subset=train)
mean((mpg-predict(lm.fit.poly,Auto))[-train]^2)
glm.fit=glm(mpg~horsepower ,data=Auto)
coef(glm.fit)
cv.err=cv.glm(Auto,glm.fit)
cv.glm=glm(mpg~horsepower,data = Auto)
cv.err=cv.glm(Auto,glm.fit)
library (boot)    # For performing the bootsrapping
library (boot)    # For performing the bootsrapping
cv.err=cv.glm(Auto,glm.fit)
print(cv.err)
cv.err$delta
setwd("D:\\Study\\Internship\\WT_PaleoCar_2017\\meteor_example\\webapppaloecar\\")
setwd("D:\\Study\\Internship\\WT_PaleoCar_2017\\meteor_example\\webapp_paloecar\\")
library(paleocar)
library(magrittr) # The magrittr package enables piping in R.
library(raster)
library(magrittr)
library(tibble)
library(readr)
library(paleocar)
library(magrittr) # The magrittr package enables piping in R.
library(raster)
library(magrittr)
library(tibble)
library(readr)
source("Rscript/wrapper_paleocar.R")
setwd("D:\\Study\\Internship\\WT_PaleoCar_2017\\meteor_example\\webapp_paloecar\\")
setwd(args[1])
# For testing th script if you want see commands on server terminal
# set techo=True
options(echo=FALSE)
## this option is used for taking the inputs from command line.
args <- commandArgs(trailingOnly = TRUE)
## Print the args for testing if needed.
# print(args)
## load the librariers.
library(paleocar)
library(magrittr)
library(raster)
library(magrittr)
library(tibble)
library(readr)
library(wrapperpaleocar)
## Create wrapper functions
############################################################
## Function for creating the Prism data,                   #
## using the NetCDF file, location coordinates.            #
## The output is a csv file                                #
############################################################
prism_data <- function(coordinates,   #Longitude and latitude.
in_file_name,  # the NetCDF file format.
out_file_name,  # the output file name.
...){
# as of now using only 112W36N.nc4 file,
# later the parameter can be passed directly.
in_file_name=in_file_name
out_file_name= out_file_name
# load the netcdf file
raster::brick(in_file_name) %>%
# extract the point
raster::extract(coordinates) %>%
# Transpose to columnar form for PaleoCAR processing
t() %>%
# Convert to tibble
tibble::as_tibble() %>%
# Save the data as a csv or NetCDF file which can be used later in the paleocar wrapper.
readr::write_csv(out_file_name) #%>%
#devtools::use_data(out_file_name, overwrite = TRUE)
}
####################################################################
## Function for executing the Paleocar Models                     ##
## Input parameters:                                              ##
## chronologies, prediction, calibration, prism data of           ##
## region, label, and test directory for saving output file       ##
## Output:                                                        ##
## Generates the plots for prediciton and uncertainty,            ##
## logs the execution output into the paleocar_model_log.txt file ##
####################################################################
run_paleocar <- function (testDir,
prism_data,
label,
itrdb,
calibration.years,
prediction.years,
verbose,
input_data_type,
...){
## Create the test directory in which the plots whould be generated
unlink(testDir)
dir.create(testDir, showWarnings=F, recursive=T)
predictands <- prism_data
chronologies <- itrdb
calibration.years <- calibration.years
prediction.years <- prediction.years
verbose = T
## log the hisotry of execution into  a file
if(input_data_type=="v"){
sink(paste0(testDir,'paleocar_model_log.txt'))
recon_vector <- paleocar_models(predictands = predictands,
chronologies = itrdb,
calibration.years = calibration.years,
prediction.years = prediction.years,
verbose = verbose)
# Generate predictions and uncertainty (and plot timeseries of each)
jpeg(paste0(testDir,'predictions.jpg'))
predict_paleocar_models(models = recon_vector,
#meanVar = "chained",
prediction.years = prediction.years) %>%
plot(x = as.numeric(names(.)),
y = .,
type = "l",
main="Predicted PPT Values Vs Prediction Years",
xlab="Prediction Years", ylab="Predcited PPT Values")
dev.off();
jpeg(paste0(testDir,'uncertainty.jpg'));
uncertainty_paleocar_models(recon_vector,
prediction.years = prediction.years) %>%
plot(x = as.numeric(names(.)),
y = .,
type = "l",
main="Uncertain PPT Values Vs Prediction Years",
xlab="Prediction Years", ylab="Uncertain PPT Values")
dev.off();
sink()
}
if(input_data_type=="m"){
sink(paste0(testDir,'paleocar_model_log.txt'))
recon_matrix <- paleocar_models(predictands = predictands,
chronologies = itrdb,
calibration.years = calibration.years,
prediction.years = prediction.years,
verbose = verbose)
# Generate predictions and uncertainty (and plot location means in uncertainty)
jpeg(paste0(testDir,'predictions.jpg'));
predict_paleocar_models(models = recon_matrix,
meanVar = "chained",
prediction.years = prediction.years) %>%
rowMeans() %>%
plot(x = as.numeric(names(.)),
y = .,
type = "l",
main="Predcited PPT Values Vs Prediction Years",
xlab="Prediction Years", ylab="Predcited PPT Values")
dev.off()
jpeg(paste0(testDir,'uncertainty.jpg'));
uncertainty_paleocar_models(models = recon_matrix,
prediction.years = prediction.years) %>%
rowMeans() %>%
plot(x = prediction.years,
y = .,
type = "l",
main="Uncertain PPT Values Vs Prediction Years",
xlab="Prediction Years", ylab="Uncertain PPT Values")
dev.off();
sink();
}
if(input_data_type=="r"){
sink(paste0(testDir,'paleocar_model_log.txt'))
## Executing PaleoCar Model for the dataset ##
recon_data <-    paleocar( predictands = predictands,
label = label,
chronologies = chronologies,
calibration.years = calibration.years,
prediction.years = prediction.years,
out.dir = testDir,
meanVar = "none",
floor = 0,
ceiling = NULL,
force.redo = T,
verbose = verbose)
sink()
## Plotting and saving the graphs for predictions generated by paleocar model##
jpeg(paste0(testDir,'predictions.jpg'))
recon_data$predictions %>%
raster::mean() %>%
raster::plot(main="Predcited PPT Values Vs Prediction Years",
xlab="Prediction Years", ylab="Predcited PPT Values")
dev.off();
## Plotting and saving the graphs for uncertainty generated by paleocar model##
jpeg(paste0(testDir,'uncertainty.jpg'))
recon_data$uncertainty %>%
raster::mean() %>%
raster::plot(main="Uncertain PPT Values Vs Prediction Years",
xlab="Prediction Years", ylab="Uncertain PPT Values")
dev.off ();
sink();
}
}
############################################################
## Function for creating the boundary for the prism data,  #
############################################################
reg_boundary <- function(in_file_name,
... ){
in_file_name= in_file_name
x<-raster::brick(in_file_name)
y<-raster::extent(x)
y<-as.vector(y)
return(cat(trimws(y[1:4])))
}
# this file is used for generating the boudary region
# the NetCdf file is used for input and
# string of lat long values is returned.
# SEt this option to true for debugging only.
options(echo=FALSE)
args <- commandArgs(trailingOnly = TRUE)
## load the libraries.
library(paleocar)
library(magrittr)
library(raster)
library(magrittr)
library(tibble)
library(readr)
#set the current project directory and
# source the wrapper function files.
setwd(args[1])
source("Rscript/wrapper_paleocar.R")
## Call reg_boundary location for getting  the extent values.
reg_boundary(paste0("data/",args[2]))
# this file is used for generating the boudary region
# the NetCdf file is used for input and
# string of lat long values is returned.
# SEt this option to true for debugging only.
options(echo=FALSE)
args <- commandArgs(trailingOnly = TRUE)
## load the libraries.
library(paleocar)
library(magrittr)
library(raster)
library(magrittr)
library(tibble)
library(readr)
#set the current project directory and
# source the wrapper function files.
setwd(args[1])
source("Rscript/wrapper_paleocar.R")
## Call reg_boundary location for getting  the extent values.
reg_boundary(paste0("data/",args[2]))
source("Rscript/wrapper_paleocar.R")
## Call reg_boundary location for getting  the extent values.
reg_boundary(paste0("data/",args[2]))
# this file is used for generating the prism data
# string of lat long values are input with the NetCDF file.
# A CSV file is generated as the output
# SEt this option to true for debugging only.
options(echo=FALSE)
args <- commandArgs(trailingOnly = TRUE)
##load the libraries for execution of the paleocar
library(paleocar)
library(magrittr)
library(raster)
library(magrittr)
library(tibble)
library(readr)
#set the current project directory and
# source the wrapper function files.
setwd(args[1])
source("Rscript/wrapper_paleocar.R")
## Get the coordinates into a matrix form for generating the required prism data file.
coord <- c(as.numeric(args[3]),as.numeric(args[2])) %>% # Longitude before latitude!
matrix(ncol = 2)
## Call the prism_Data function for creating the csv file for the vectors
prism_data(coord,paste0("data/",args[4]), paste0("data/",args[5]))
cat("Success")
# this file is used for generating the prism data
# string of lat long values are input with the NetCDF file.
# A CSV file is generated as the output
# SEt this option to true for debugging only.
options(echo=FALSE)
args <- commandArgs(trailingOnly = TRUE)
##load the libraries for execution of the paleocar
library(paleocar)
library(magrittr)
library(raster)
library(magrittr)
library(tibble)
library(readr)
#set the current project directory and
# source the wrapper function files.
setwd(args[1])
source("Rscript/wrapper_paleocar.R")
## Get the coordinates into a matrix form for generating the required prism data file.
coord <- c(as.numeric(args[3]),as.numeric(args[2])) %>% # Longitude before latitude!
matrix(ncol = 2)
## Call the prism_Data function for creating the csv file for the vectors
prism_data(coord,paste0("data/",args[4]), paste0("data/",args[5]))
cat("Success")
# this file is used for generating the boudary region
# the NetCdf file is used for input and
# string of lat long values is returned.
# SEt this option to true for debugging only.
options(echo=TRUE)
args <- commandArgs(trailingOnly = TRUE)
## load the libraries.
library(paleocar)
library(magrittr)
library(raster)
library(magrittr)
library(tibble)
library(readr)
#set the current project directory and
# source the wrapper function files.
setwd(args[1])
source("Rscript/wrapper_paleocar.R")
## Call reg_boundary location for getting  the extent values.
reg_boundary(paste0("data/",args[2]))
